import { createBoardWithRiver } from '../../utils/boardGenerator.js';
import { pushState } from 'redux-router';

import { randomNumber } from '../../utils/generalFunctions';
import { allUnits } from '../../utils/Units';

export const navigate = (path) => pushState(null, path);

export function searchNewGame( userId ) {
  console.log(">>>>>>> searchNewGame" );
  return ( dispatch, getState ) => {
    const { firebase } = getState( );
    /*
     NOTE:
     Since this code is not easy to understand, here goes some hints:
     1ยบ) If nobody is waiting for a game, then you'll be that one.
     2ยบ) If there is already somebody, you'll be on a temporal sub-matchmaking list
          in order to avoid concurrence, ensuring only one person is getting matched
          with another one.
     3ยบ) The matchmaking criteria is the autogenerated timestamp-based push's Id.
          He who cames the first, should be the first, regadless the biblia! >:C
     4ยบ) To ensure nobody access to the board, generating glitches, the waiter and it's
          sublist of players are removed BEFORE the creation of the Board.
    */
    const matchListSnapshot = firebase.child('matchmaking');
    matchListSnapshot.once("value", (snapshot)=>{
      console.log(">>>>>>> snapshot.value = "+snapshot.hasChildren() );
      snapshot.hasChildren() ? matchmake( userId ) : addToMatchmaking( );
    });

    function matchmake( userId, ref = matchListSnapshot ) {
      console.log(">>>>>>> MATCHMAKE" );
      addToFirstOpponentList( userId );
      ref.startAt().limitToFirst(1).once("child_added", (snapshot)=>{
        const opponentTmpId = snapshot.key();
        const opponentId = snapshot.child("userId").val();
        console.log(">>>>>>> opponentId"+opponentId );
          firebase.child(`matchmaking/${opponentTmpId}/userList/`).startAt().limitToFirst(1).once("child_added", (snapshot)=>{
            console.log(">>>>>>>\"snapshot=\""+snapshot.key() );
            snapshot.val().userId === userId ?
              ( firebase.child(`matchmaking/${opponentTmpId}`).remove(),
                createNewBoard( opponentId, userId, firebase) ):
              setTimeout(searchNewGame( userId ), 1000);
          });
      });
    }


    function addToFirstOpponentList( userId, ref = matchListSnapshot ) {
      console.log(">>>>>>> addToFirstOpponentList" );
      ref.startAt().limitToFirst(1).once("child_added", (snapshot)=>{
        const opponentTmpId = snapshot.key() ;
        const listRef = firebase.child(`matchmaking/${opponentTmpId}/userList/`);
        listRef.push( {
          "userId": userId
        });
      });
    }

    function addToMatchmaking( ref = matchListSnapshot ) {
      console.log(">>>>>>> addToMatchmaking" );
      ref.push( {
        "userId": userId,
        "userList": { }
      } );
    }

/*    const matchmakingReference = firebase.child('matchmaking');
      matchmakingReference.transaction( matchmaking => {
      const matchmakingArray = matchmaking || [];
      return matchmakingArray.concat(userId);
    }, (e, complete, array) => {
      console.log(">>>>>", e, complete, array.val());
      if (complete) {
        firebase.child('matchmaking').transaction( matchmaking => {
          const matchmakingArray = matchmaking || [];
          while(matchmakingArray.length > 1) {
            console.log(matchmakingArray.shift());
            console.log(matchmakingArray.shift());
          }
          return matchmakingArray;
        }, () => {}, false);
      }
    }, false);
*/  };
}

function createNewBoard(idOne, idTwo, firebase = firebase) {
  let newBoard = createBoardWithRiver(8, 2, 'river');
  newBoard = fillBoardWithUnits(newBoard);
  const newBoardReference = firebase.child('boards').push({board: newBoard, turn: idOne, 0: idOne, 1: idTwo});
  const newBoardId = newBoardReference.key();
  addBoardToUser(idOne, newBoardId, firebase);
  addBoardToUser(idTwo, newBoardId, firebase);
}

function fillBoardWithUnits(board) {
  for (let i = 0; i < 6; i++) {
    const unit = allUnits[randomNumber(0, 22)];
    board = placeOneUnit(unit, board, 0);
    board = placeOneUnit(unit, board, 1);
  };
  return board;
}

function placeOneUnit(unit, board, side) {
  const boardSize = board.length;
  const positionX = randomNumber(0, boardSize);
  const positionY = side === 0 ? randomNumber(0, Math.floor(boardSize / 2)) : randomNumber(Math.ceil(boardSize / 2), boardSize);
  if(board[positionX][positionY].passable === false || board[positionX][positionY].unit != null) {
    board = placeOneUnit(unit, board, side);
  }else{
    unit = Object.assign({}, unit, {army: side});
    board[positionX][positionY] = Object.assign({}, board[positionX][positionY], {unit: unit});
  }
  return board;
}

function addBoardToUser(userId, boardId, firebase) {
  firebase.child(`users/${userId}/myBoards`).once('value', snapshot => {
    const oldBoards = snapshot.val() || [];
    firebase.child(`users/${userId}/myBoards`).set([boardId, ...oldBoards]);
  });
}

export function updateBoard(board, boardId) {
	return (dispatch, getState) => {
    const { firebase } = getState();
    firebase.child(`boards/${boardId}/board`).set(board);
  };
}

